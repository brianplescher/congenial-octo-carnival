<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Fiction Editor - Brian Plescher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Editor-specific styles */
        .editor-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-lg);
        }
        
        .password-screen {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: var(--background);
        }
        
        .password-form {
            background: white;
            padding: var(--space-2xl);
            border-radius: var(--border-radius-md);
            box-shadow: 0 4px 24px var(--softshadow);
            max-width: 400px;
            width: 100%;
        }
        
        .editor-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: var(--space-xl);
            margin-top: var(--space-xl);
        }
        
        .controls-panel {
            background: white;
            padding: var(--space-xl);
            border-radius: var(--border-radius-md);
            box-shadow: 0 4px 24px var(--softshadow);
            height: fit-content;
            position: sticky;
            top: var(--space-lg);
        }
        
        .editor-main {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }
        
        .text-input {
            background: white;
            border-radius: var(--border-radius-md);
            box-shadow: 0 4px 24px var(--softshadow);
            overflow: hidden;
        }
        
        .text-input textarea {
            width: 100%;
            min-height: 300px;
            padding: var(--space-xl);
            border: none;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            line-height: 1.6;
            resize: vertical;
            background: transparent;
        }
        
        .text-input textarea:focus {
            outline: none;
        }
        
        .paragraph-results {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }
        
        .paragraph-card {
            background: white;
            border-radius: var(--border-radius-md);
            box-shadow: 0 4px 24px var(--softshadow);
            overflow: hidden;
            border-left: 4px solid var(--indigo);
        }
        
        .paragraph-header {
            background: var(--footer);
            padding: var(--space-md) var(--space-xl);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        
        .paragraph-content {
            padding: var(--space-xl);
        }
        
        .paragraph-actions {
            display: flex;
            gap: var(--space-sm);
        }
        
        .btn-small {
            padding: var(--space-xs) var(--space-md);
            font-size: 0.9rem;
            border: none;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-weight: 500;
            transition: all var(--transition-fast);
        }
        
        .btn-accept {
            background: var(--success);
            color: white;
        }
        
        .btn-reject {
            background: var(--error);
            color: white;
        }
        
        .btn-export {
            background: var(--indigo);
            color: white;
        }
        
        .btn-small:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .form-group {
            margin-bottom: var(--space-lg);
        }
        
        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: var(--space-sm);
            color: var(--deepblue);
        }
        
        .form-group select,
        .form-group textarea,
        .form-group input {
            width: 100%;
            padding: var(--space-md);
            border: 2px solid #e0e0e0;
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: 1rem;
            transition: border-color var(--transition-fast);
        }
        
        .form-group select:focus,
        .form-group textarea:focus,
        .form-group input:focus {
            border-color: var(--indigo);
            outline: none;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-lg);
        }
        
        .processing {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .error-message {
            background: rgba(185, 28, 28, 0.1);
            color: var(--error);
            padding: var(--space-md);
            border-radius: var(--border-radius-sm);
            margin-top: var(--space-md);
        }
        
        .guidance-preview {
            background: var(--footer);
            padding: var(--space-md);
            border-radius: var(--border-radius-sm);
            font-size: 0.9rem;
            color: var(--muted);
            white-space: pre-line;
            max-height: 200px;
            overflow-y: auto;
            margin-top: var(--space-md);
        }
        
        @media (max-width: 1200px) {
            .editor-grid {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                position: static;
            }
        }
    </style>
</head>
<body>
    <!-- Password Screen -->
    <div id="passwordScreen" class="password-screen">
        <div class="password-form">
            <h1 style="margin-bottom: var(--space-lg); text-align: center;">Hidden Editor Access</h1>
            <div class="form-group">
                <input type="password" id="passwordInput" placeholder="Enter password" />
            </div>
            <button class="btnlink" onclick="checkPassword()" style="width: 100%;">Enter</button>
            <div id="passwordError" class="error-message" style="display: none;">Incorrect password</div>
        </div>
    </div>

    <!-- Main Editor Interface -->
    <div id="editorInterface" style="display: none;">
        <nav>
            <div class="nav-left">
                <div class="brand"><a href="index.html">Brian Plescher</a></div>
                <span class="nav-separator">•</span>
                <div class="nav-primary-link">Historical Fiction Editor</div>
            </div>
            <div class="navlinks">
                <a href="index.html">Home</a>
                <a href="essays.html">Essays</a>
            </div>
        </nav>

        <div class="editor-container">
            <div class="editor-grid">
                <!-- Controls Panel -->
                <div class="controls-panel">
                    <h2 style="margin-top: 0;">Editor Controls</h2>
                    
                    <div class="form-group">
                        <label for="apiKey">OpenAI API Key (optional)</label>
                        <input type="password" id="apiKey" placeholder="sk-..." />
                        <small style="color: var(--muted); font-size: 0.9rem;">Leave blank to be prompted when needed</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="chapterSelect">Chapter</label>
                        <select id="chapterSelect" onchange="updateGuidance()">
                            <option value="1">Chapter 1</option>
                            <option value="2">Chapter 2</option>
                            <option value="3">Chapter 3</option>
                            <option value="4">Chapter 4</option>
                            <option value="5">Chapter 5</option>
                            <option value="6">Chapter 6</option>
                            <option value="7">Chapter 7</option>
                            <option value="8">Chapter 8</option>
                            <option value="9">Chapter 9</option>
                            <option value="10">Chapter 10</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="customGuidance">Additional Context</label>
                        <textarea id="customGuidance" rows="3" placeholder="Optional custom guidance..." onchange="updateGuidance()"></textarea>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="deletionMode" onchange="updateGuidance()">
                        <label for="deletionMode">Deletion Mode (Remove excess)</label>
                    </div>
                    
                    <button class="btnlink" onclick="processText()" id="processBtn" style="width: 100%;">
                        Process Text
                    </button>
                    
                    <div class="guidance-preview" id="guidancePreview"></div>
                </div>

                <!-- Main Editor Area -->
                <div class="editor-main">
                    <div class="text-input">
                        <textarea id="originalText" placeholder="Paste your text here to edit..."></textarea>
                    </div>
                    
                    <div id="results" class="paragraph-results"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core Data
        const TECHNIQUES = {
            MW: 'Material Witness',
            PP: 'Polyphonic Possession', 
            NH: 'Negative Historiography',
            AK: 'Abjection as Knowledge',
            TC: 'Temporal Collapse',
            LO: 'Labor as Ontology',
            SAP: 'Sensory Anchor Portal'
        };

        const CHAPTER_MAP = {
            1: { MW: 1, NH: 2, TC: 1, SAP: 3 },
            2: { NH: 3, SAP: 2 },
            3: { MW: 3, NH: 1, SAP: 2 },
            4: { PP: 3, TC: 3 },
            5: { PP: 1, AK: 3, TC: 1 },
            6: { MW: 3, PP: 3, NH: 3, AK: 1, TC: 3, SAP: 3 },
            7: { AK: 3, LO: 3, SAP: 1 },
            8: { MW: 1, PP: 2, NH: 3, TC: 1 },
            9: { MW: 2, NH: 1, AK: 2, LO: 2 },
            10: { MW: 2, PP: 1, TC: 2, LO: 2, SAP: 2 }
        };

        const PLOT_FUNCTIONS = {
            1: "Entry/Threshold — narrator enters charged landscape, movement through space, first sensory anchor contact, no inciting incident",
            2: "Orientation Through Absence — world explained by what's missing, gaps in records/maps, authority encountered indirectly", 
            3: "Pattern Emergence — repetition reveals structure, objects recur, spaces revisited, quiet recognition through accumulation",
            4: "Compression — pressure replaces progression, tasks accelerate, interior/exterior collapse, shift from observation to occupation",
            5: "Fracture — narrative coherence fails, bodily strain/breakdown, contradictory sequences, crisis not climax",
            6: "The Grinding Stones (KEYSTONE) — past and present fully coexist, historical labor intrudes bodily, possession not memory, structural center",
            7: "Human Labor — meaning enacted not interpreted, sustained physical work, exhaustion replaces insight, rebuilds through body",
            8: "Recognition Without Resolution — understanding arrives but solves nothing, awareness sharpens, no action follows, refuses catharsis",
            9: "Reverberation — consequences unfold quietly, small gestures, spaces register what occurred, aftermath without spectacle",
            10: "Integration/Exit — return to threshold, sensory anchor reappears altered, closure through recontextualization not resolution"
        };

        const FORBIDDEN = {
            1: "No backstory. No motivation statements. No explanation of arrival.",
            2: "No historical exposition. No corrective narration. No filling gaps.",
            3: "No symbolic interpretation of objects. No thematic summary.",
            4: "No pauses for reflection. No clarifying transitions.",
            5: "No repair of coherence. No emotional resolution.",
            6: "No dates. No named historical explanations. No interpretive framing of stones.",
            7: "No metaphorical labor. No insight following work. No abstraction.",
            8: "No decisions. No actions taken. No moral resolution.",
            9: "No dramatization of aftermath. No explicit consequence statements.",
            10: "No summative explanation. No meaning statements. No closure language."
        };

        // State
        let paragraphs = [];
        let currentIndex = -1;
        let processing = false;

        // Password check
        function checkPassword() {
            const input = document.getElementById('passwordInput').value;
            const correctPassword = 'hidden123'; // You can change this
            
            if (input === correctPassword) {
                document.getElementById('passwordScreen').style.display = 'none';
                document.getElementById('editorInterface').style.display = 'block';
                updateGuidance();
            } else {
                document.getElementById('passwordError').style.display = 'block';
            }
        }

        // Generate guidance text
        function generateTechniqueGuidance(chapterNum) {
            const techniques = CHAPTER_MAP[chapterNum] || {};
            const plotFunction = PLOT_FUNCTIONS[chapterNum] || '';
            const deletionMode = document.getElementById('deletionMode').checked;
            const customGuidance = document.getElementById('customGuidance').value;
            
            const dominant = [];
            const active = [];
            const present = [];
            
            Object.entries(techniques).forEach(([code, level]) => {
                const name = TECHNIQUES[code];
                if (level === 3) dominant.push(name);
                else if (level === 2) active.push(name);
                else if (level === 1) present.push(name);
            });

            let guidance = `CHAPTER ${chapterNum} ARCHITECTURE:\n${plotFunction}\n\n`;
            guidance += `APPLY THESE TECHNIQUES:\n`;
            if (dominant.length) guidance += `DOMINANT: ${dominant.join(', ')}\n`;
            if (active.length) guidance += `ACTIVE: ${active.join(', ')}\n`;
            if (present.length) guidance += `PRESENT: ${present.join(', ')}\n`;
            
            guidance += `\nTECHNIQUE DEFINITIONS:\n`;
            guidance += `- Material Witness: Objects testify through wear/damage/persistence, not symbolism. NO interpretation.\n`;
            guidance += `- Polyphonic Possession: Multiple consciousnesses inhabit narrator without quotation marks/framing. NO reflection on possession.\n`;
            guidance += `- Negative Historiography: Meaning from gaps/erasure/missing docs. Name what's absent, don't fill it. NO exposition.\n`;
            guidance += `- Abjection as Knowledge: Understanding through bodily degradation. Sensation BEFORE thought. NO aestheticizing suffering.\n`;
            guidance += `- Temporal Collapse: Multiple times in same sentence, no hierarchy. NO clear before/after. NO flashback framing.\n`;
            guidance += `- Labor as Ontology: Identity through repetitive physical work. Thought emerges FROM action. NO metaphorical labor.\n`;
            guidance += `- Sensory Anchor Portal: Concrete sensation opens temporal layers involuntarily. NO "I remembered." NO explanation.\n\n`;
            
            guidance += `CRITICAL STRUCTURAL PRINCIPLE:\n`;
            guidance += `This book's plot is TECTONIC not DRAMATIC. Pressure replaces conflict. Contact replaces climax. Reverberation replaces resolution. If a passage feels "slow" or "thin," that may be correct architecture. Do not add false drama. Do not create conflict where pressure suffices.\n`;

            if (FORBIDDEN[chapterNum]) {
                guidance += `\nFORBIDDEN IN THIS CHAPTER:\n${FORBIDDEN[chapterNum]}\n`;
            }

            if (deletionMode) {
                guidance += `\nEDITING MODE:\nIf the paragraph already conforms, improve it by REMOVING excess explanation, softening emphasis, or tightening sentences. Do not add imagery or insight unless structurally necessary.\n`;
            }

            if (customGuidance) {
                guidance += `\nADDITIONAL CONTEXT: ${customGuidance}`;
            }

            return guidance;
        }

        function updateGuidance() {
            const chapter = document.getElementById('chapterSelect').value;
            const guidance = generateTechniqueGuidance(parseInt(chapter));
            document.getElementById('guidancePreview').textContent = guidance;
        }

        function splitIntoParagraphs(text) {
            return text.split(/\n\n+/).map(p => p.trim()).filter(p => p);
        }

        async function processText() {
            const originalText = document.getElementById('originalText').value.trim();
            if (!originalText) {
                alert('Please enter some text to process.');
                return;
            }

            processing = true;
            document.getElementById('processBtn').textContent = 'Processing...';
            document.getElementById('processBtn').disabled = true;

            try {
                paragraphs = splitIntoParagraphs(originalText).map((text, index) => ({
                    id: index,
                    original: text,
                    edited: null,
                    status: 'pending'
                }));

                renderResults();
                
                // Process each paragraph
                for (let i = 0; i < paragraphs.length; i++) {
                    currentIndex = i;
                    await processOneParagraph(i);
                }

            } catch (error) {
                console.error('Processing error:', error);
                document.getElementById('results').innerHTML = `
                    <div class="error-message">
                        Error processing text: ${error.message}
                    </div>
                `;
            } finally {
                processing = false;
                document.getElementById('processBtn').textContent = 'Process Text';
                document.getElementById('processBtn').disabled = false;
                currentIndex = -1;
            }
        }

        async function processOneParagraph(index) {
            const paragraph = paragraphs[index];
            const chapter = document.getElementById('chapterSelect').value;
            const guidance = generateTechniqueGuidance(parseInt(chapter));
            
            // Update UI to show processing
            renderResults();

            try {
                // Simulate API call - replace with actual API endpoint
                const response = await simulateAPICall(paragraph.original, guidance);
                
                paragraph.edited = response.edited_text;
                paragraph.status = 'completed';
                
            } catch (error) {
                paragraph.status = 'error';
                paragraph.error = error.message;
            }
            
            renderResults();
        }

        // API call to process text
        async function simulateAPICall(text, guidance) {
            // First try the serverless function (if deployed on Vercel)
            try {
                const response = await fetch('/api/edit', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        guidance: guidance
                    })
                });

                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.log('Serverless function not available, using direct API call');
            }

            // Fallback to direct OpenAI API call
            let apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                apiKey = prompt('Enter your OpenAI API key (this will not be stored):');
                if (!apiKey) {
                    throw new Error('API key required');
                }
            }

            const prompt = `You are a historical fiction editor specializing in experimental narrative techniques. Your task is to edit the provided paragraph according to the specific guidance below.

GUIDANCE:
${guidance}

PARAGRAPH TO EDIT:
${text}

Please edit this paragraph to align with the guidance. Return only the edited paragraph, no explanations or commentary.`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: 'gpt-4',
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a skilled historical fiction editor who specializes in experimental narrative techniques. You edit text to conform to specific literary techniques while maintaining the original meaning and voice.'
                        },
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    max_tokens: 1000,
                    temperature: 0.7,
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || `HTTP ${response.status}`);
            }

            const data = await response.json();
            const editedText = data.choices[0]?.message?.content?.trim();

            if (!editedText) {
                throw new Error('No edited text received from AI');
            }

            return {
                edited_text: editedText,
                original_text: text,
                guidance_used: guidance
            };
        }

        function renderResults() {
            const resultsDiv = document.getElementById('results');
            
            if (paragraphs.length === 0) {
                resultsDiv.innerHTML = '';
                return;
            }

            resultsDiv.innerHTML = paragraphs.map((paragraph, index) => {
                const isProcessing = currentIndex === index && processing;
                const statusClass = paragraph.status === 'completed' ? 'completed' : 
                                  paragraph.status === 'error' ? 'error' : 'pending';
                
                return `
                    <div class="paragraph-card ${statusClass}">
                        <div class="paragraph-header">
                            <span>Paragraph ${index + 1}</span>
                            <div class="paragraph-actions">
                                ${paragraph.status === 'completed' ? `
                                    <button class="btn-small btn-accept" onclick="acceptParagraph(${index})">Accept</button>
                                    <button class="btn-small btn-reject" onclick="rejectParagraph(${index})">Reject</button>
                                    <button class="btn-small btn-export" onclick="exportParagraph(${index})">Export</button>
                                ` : ''}
                            </div>
                        </div>
                        <div class="paragraph-content">
                            <div style="margin-bottom: var(--space-md);">
                                <strong>Original:</strong>
                                <p style="margin-top: var(--space-sm); color: var(--muted);">${paragraph.original}</p>
                            </div>
                            ${paragraph.edited ? `
                                <div>
                                    <strong>Edited:</strong>
                                    <p style="margin-top: var(--space-sm); color: var(--text);">${paragraph.edited}</p>
                                </div>
                            ` : isProcessing ? `
                                <div style="color: var(--indigo); font-style: italic;">Processing...</div>
                            ` : paragraph.status === 'error' ? `
                                <div class="error-message">Error: ${paragraph.error}</div>
                            ` : `
                                <div style="color: var(--muted); font-style: italic;">Waiting to process...</div>
                            `}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function acceptParagraph(index) {
            paragraphs[index].status = 'accepted';
            renderResults();
        }

        function rejectParagraph(index) {
            paragraphs[index].status = 'rejected';
            renderResults();
        }

        function exportParagraph(index) {
            const paragraph = paragraphs[index];
            const textToExport = paragraph.edited || paragraph.original;
            
            // Copy to clipboard
            navigator.clipboard.writeText(textToExport).then(() => {
                alert('Paragraph copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = textToExport;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Paragraph copied to clipboard!');
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Allow Enter key in password field
            document.getElementById('passwordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });
        });
    </script>
</body>
</html>